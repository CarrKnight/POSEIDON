package uk.ac.ox.oxfish.fisher.strategies.destination;

import uk.ac.ox.oxfish.fisher.DockingListener;
import uk.ac.ox.oxfish.fisher.Fisher;
import uk.ac.ox.oxfish.fisher.selfanalysis.HourlyProfitInTripObjective;
import uk.ac.ox.oxfish.fisher.selfanalysis.ObjectiveFunction;
import uk.ac.ox.oxfish.geography.SeaTile;
import uk.ac.ox.oxfish.geography.ports.Port;
import uk.ac.ox.oxfish.model.FishState;
import uk.ac.ox.oxfish.utility.adaptation.ExploreImitateAdaptation;
import uk.ac.ox.oxfish.utility.adaptation.maximization.AdaptationAlgorithm;
import uk.ac.ox.oxfish.utility.adaptation.probability.AdaptationProbability;

import java.util.function.Predicate;

/**
 *
 * In reality just a facade for a specialized PerTripIterativeDestination Strategy with an imitative algorithm.
 * Uses docking event to count (so basically only counts finished trips)
 * Created by carrknight on 6/11/17.
 */
public class ExploreExploitImitateDestinationStrategy extends PerTripIterativeDestinationStrategy implements
        DockingListener {


    public final static String EXPLORING_COLUMN_NAME = "Trips Exploring";
    public final static String EXPLOITING_COLUMN_NAME = "Trips Exploiting";
    public final static String IMITATING_COLUMN_NAME = "Trips Imitating";


    private final ExploreImitateAdaptation<SeaTile> adaptation;

    public ExploreExploitImitateDestinationStrategy(
            FavoriteDestinationStrategy delegate,
            ExploreImitateAdaptation<SeaTile> adaptation) {
        super(delegate, adaptation);
        this.adaptation = adaptation;
    }

    public ExploreExploitImitateDestinationStrategy(
            FavoriteDestinationStrategy delegate,
            AdaptationAlgorithm<SeaTile> algorithm,
            AdaptationProbability probability,
            final ObjectiveFunction<Fisher> objective,
            final Predicate<SeaTile> explorationValidator,
            final boolean ignoreFailedTrips
    )
    {
        super(delegate, algorithm, probability, objective, explorationValidator, ignoreFailedTrips);
        this.adaptation = ((ExploreImitateAdaptation<SeaTile>) super.getAlgorithm());
    }

    public ExploreExploitImitateDestinationStrategy(
            FavoriteDestinationStrategy delegate,
            AdaptationAlgorithm<SeaTile> algorithm, double randomizationProbability, double imitationProbability,
            HourlyProfitInTripObjective objective,
            Predicate<SeaTile> explorationValidator) {
        super(delegate, algorithm, randomizationProbability, imitationProbability, objective, explorationValidator);
        this.adaptation = ((ExploreImitateAdaptation<SeaTile>) super.getAlgorithm());

    }


    @Override
    public void start(FishState model, Fisher fisher) {
        super.start(model, fisher);
        fisher.addDockingListener(this);
        //if this column doesn't exist, then create them in the counter!
        if (!fisher.getYearlyCounter().hasColumn(EXPLORING_COLUMN_NAME)) {
            fisher.getYearlyCounter().addColumn(EXPLORING_COLUMN_NAME);
            fisher.getYearlyCounter().addColumn(EXPLOITING_COLUMN_NAME);
            fisher.getYearlyCounter().addColumn(IMITATING_COLUMN_NAME);

        } else {
            assert fisher.getYearlyCounter().hasColumn(EXPLOITING_COLUMN_NAME);
            assert fisher.getYearlyCounter().hasColumn(IMITATING_COLUMN_NAME);
        }
    }

    /**
     * tell the startable to turnoff,
     *
     * @param fisher
     */
    @Override
    public void turnOff(Fisher fisher) {
        super.turnOff(fisher);
        fisher.removeDockingListener(this);
    }

    //count as a finished exploratory/imitative/explotative trip
    @Override
    public void dockingEvent(Fisher fisher, Port port) {
        if(adaptation.getStatus()!=null)
            switch(adaptation.getStatus()){
                case IMITATING:
                    fisher.getYearlyCounter().count(IMITATING_COLUMN_NAME,1);
                    break;
                default:
                case EXPLORING:
                    fisher.getYearlyCounter().count(EXPLORING_COLUMN_NAME,1);
                    break;
                case EXPLOITING:
                    fisher.getYearlyCounter().count(EXPLOITING_COLUMN_NAME,1);
                    break;
            }
    }
}
