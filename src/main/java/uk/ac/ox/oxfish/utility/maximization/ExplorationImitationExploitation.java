package uk.ac.ox.oxfish.utility.maximization;

import ec.util.MersenneTwisterFast;
import uk.ac.ox.oxfish.fisher.Fisher;
import uk.ac.ox.oxfish.fisher.selfanalysis.ObjectiveFunction;
import uk.ac.ox.oxfish.model.FishState;
import uk.ac.ox.oxfish.utility.Pair;

import java.util.Collection;
import java.util.function.Function;
import java.util.function.Predicate;

/**
 * A general algorithm to perform exploration/imitaiton/exploitation decisions possibly of multiple variables
 * Created by carrknight on 8/6/15.
 */
public class ExplorationImitationExploitation<T> {


    /**
     * each "step" the validator makes sure the fisher is ready to adapt; if it returns false the adaptation is aborted
     */
    private final Predicate<Fisher> validator;


    /**
     * function to grab eligible friends
     */
    private Function<Pair<Fisher,MersenneTwisterFast>,Collection<Fisher>> friendExtractor =
            input -> input.getFirst().getDirectedFriends();


    /**
     * what the agent ought to do to adapt
     */
    private final ExplorationExploitationAlgorithm<T> algorithm;

    /**
     * a class that assigns a new T to the fisher
     */
    private final Actuator<T> actuator;

    /**
     * how the agent should judge himself and others
     */
    private final ObjectiveFunction<Fisher>  objective;



    /**
     * probability of Exploring
     */
    private final double explorationProbability;

    /**
     * probability of imitatating (conditional on not exploring)
     */
    private final double imitationProbability;

    /**
     * holds the starting point of a randomization
     */
    private Pair<T,Double> explorationStart;

    private final Sensor<T> sensor;


    public ExplorationImitationExploitation(
            Predicate<Fisher> validator,
            ExplorationExploitationAlgorithm<T> decision,
            Actuator<T> actuator,
            Sensor<T> sensor,
            ObjectiveFunction<Fisher> objective, double explorationProbability,
            double imitationProbability) {
        this.validator = validator;
        this.algorithm = decision;
        this.actuator = actuator;
        this.objective = objective;
        this.explorationProbability = explorationProbability;
        this.imitationProbability = imitationProbability;
        this.sensor = sensor;
    }

    public ExplorationImitationExploitation(
            Predicate<Fisher> validator,
            Function<Pair<Fisher,MersenneTwisterFast>,Collection<Fisher>> friendsExtractor,
            ExplorationExploitationAlgorithm<T> decision,
            Actuator<T> actuator,
            Sensor<T> sensor,
            ObjectiveFunction<Fisher> objective, double explorationProbability,
            double imitationProbability) {
        this.validator = validator;
        this.friendExtractor = friendsExtractor;
        this.algorithm = decision;
        this.actuator = actuator;
        this.objective = objective;
        this.explorationProbability = explorationProbability;
        this.imitationProbability = imitationProbability;
        this.sensor = sensor;
    }

    public void start(Fisher toAdapt,FishState state){
        algorithm.start(state, toAdapt);
    }

    /**
     * the simple loop: check whether to randomize, imitate or exploit
     * @param toAdapt who is doing the adaptation
     * @param random the randomizer
     */
    public void adapt(Fisher toAdapt, MersenneTwisterFast random)
    {

        //are you ready?
        if(!validator.test(toAdapt))
            return;


        //check your fitness and where you are
        double fitness = objective.computeCurrentFitness(toAdapt);
        T current =  sensor.scan(toAdapt);

        //if you explored in the previous step
        if(explorationStart != null)
        {
            T decision = this.algorithm.judgeRandomization(random, toAdapt,
                                                           explorationStart.getSecond(), fitness,
                                                           current,explorationStart.getFirst());
            act(toAdapt, decision);
            current = decision; //you might have switched
            explorationStart = null;
        }

        //you are ready

        //explore?
        if(random.nextBoolean(explorationProbability)) {

            T future = algorithm.randomize(random, toAdapt, fitness,current);
            explorationStart = new Pair<>(current,fitness);
            act(toAdapt,future);
            return;
        }

        assert  explorationStart==null;

        //imitate?
        Collection<Fisher> friends = friendExtractor.apply(new Pair<>(toAdapt, random));
        if(!friends.isEmpty() && random.nextBoolean(imitationProbability))
        {

            act(toAdapt,
                algorithm.imitate(random,
                                  toAdapt, fitness, current,
                                  friends,objective,sensor));
            return;

        }


        //no imitation, no exploration
        //exploit:
        act(toAdapt,
            algorithm.exploit(random, toAdapt, fitness, current));


    }


    private void act(Fisher toAdapt,T newVariable)
    {
        if(newVariable != sensor.scan(toAdapt))
            actuator.apply(toAdapt,newVariable);
    }

    public Function<Pair<Fisher, MersenneTwisterFast>, Collection<Fisher>> getFriendExtractor() {
        return friendExtractor;
    }

    public void setFriendExtractor(
            Function<Pair<Fisher, MersenneTwisterFast>, Collection<Fisher>> friendExtractor) {
        this.friendExtractor = friendExtractor;
    }
}
